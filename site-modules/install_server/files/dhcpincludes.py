#!/bin/env python3
#
#

"""
Generate dynamic dhcp include files based on a list of directories.

 The configuration file is a yaml file containing the following keys:
   service-name: The name of the systemd service for dhcpd;
   dhcpd: The full path to the dhcpd binary;
   dccpd.conf: The full path of the top level dhcpd.conf;
   paths: A list of dictionaries containing a path and a file key each,
   specifying a path to build includes from and a file to write the includes to.
"""

import argparse
import logging
import subprocess
import sys

from pathlib import Path

from wmflib.fileio import locked_open
from wmflib.config import load_yaml_config

logger = logging.getLogger()

EXIT_SUCCESS = 0
EXIT_TEST_FAILED = 1
EXIT_RESTART_FAILED = 2
LOCKFILE = "/run/dhcpincludes.lock"


def parse_command_line_args():
    """Parse command line options."""
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("-c",
                        "--config",
                        help="The path to the configuration yaml file to load",
                        default="/etc/dhcp/dhcpincludes.yaml",
                        type=Path)
    parser.add_argument("-r",
                        "--reload",
                        help="Reload dhcp server after building and testing",
                        action="store_true")
    parser.add_argument("-v", "--verbose", help="Output more verbosity.", action="store_true")
    sc = parser.add_subparsers(dest="command")
    sc.add_parser("commit")

    args = parser.parse_args()
    return args


def setup_logging(verbose=False):
    """Setup the logging with a custom format to go to stdout."""
    if not verbose:
        level = logging.INFO
    else:
        level = logging.DEBUG

    logging.basicConfig(level=level, format="%(asctime)s [%(levelname)s] %(message)s")


def get_includes_for_path(path):
    """Generate a DHCP include line for each file in a path."""
    includes = []
    for inc in path.glob("*.conf"):
        if inc.is_file():
            includes.append(f'include "{inc.absolute()}";')

    return "\n".join(includes)


def main():
    """
    Main routine:
    * Process command line arguments
    * Set up logging
    * Iterate paths in configuration file and generate include files.
    * Test the dhcpd configuration (and exit if failed)
    * Optionally restart dhcpd
    """
    args = parse_command_line_args()
    setup_logging(args.verbose)
    cfg = load_yaml_config(args.config)

    if args.command is None:
        logger.warning("*** Test mode. Cowardly refusing to alter files.")
        logger.warning("*** Pass `commit` to actually perform configuration change.")

    # Lock so we only run one copy at once
    with locked_open(Path(LOCKFILE), "w"):
        # Build include proxies
        for path in cfg["paths"]:
            includes = get_includes_for_path(Path(path["path"]))
            if args.command == "commit":
                logger.info(f"Writing file {path['file']}")
                with open(path["file"], "w") as output:
                    output.write(f"# Automatically generated by dhcpincludes for {path['path']}\n")
                    output.write(includes)
            else:
                logger.info(f"Would have written file {path['file']}")
                logger.debug("Contents of file:")
                logger.debug(includes)

        # Test config
        if subprocess.call([cfg["dhcpd"], "-t", "-cf", cfg["dhcpd.conf"]]) != 0:
            logger.error("dhcp config test returned non-zero.")
            return EXIT_TEST_FAILED
        logger.info("dhcp config test passed!")

        # Reload config if requested
        if args.reload and args.command == "commit":
            if subprocess.call(["/usr/bin/systemctl", "restart", cfg["service-name"]]) != 0:
                logger.error(f"dhcp service {cfg['service-name']} reload returned non-zero.")
                return EXIT_RESTART_FAILED
            logger.info(f"reloaded {cfg['service-name']}")

    return EXIT_SUCCESS


if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception:
        logger.exception("Unexpected exception occurred")
