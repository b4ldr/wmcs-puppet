#!/usr/bin/python3
import argparse
import logging
import os
import sys
import yaml
import fcntl


log = logging.getLogger()

# Assumptions/limitations
# * not site aware
# * for a given role, its 'master host' is the first listed host


class Pontoon(object):
    def __init__(self, config):
        self.config = yaml.safe_load(config)

    def host_map(self):
        """Given a role -> hosts configuration, return a host -> role map."""
        res = {}
        for role, hosts in self.config.items():
            for h in hosts:
                if h in res:
                    log.warning("Duplicate host %s", h)
                    continue
                res[h] = role
        return res

    def role_variables(self):
        """Variables for all roles, used to factor hostnames out of hiera."""
        res = {}
        for role, hosts in self.config.items():
            res["__hosts_for_role_%s" % role.replace(":", "_")] = hosts
            res["__master_for_role_%s" % role.replace(":", "_")] = hosts[0]
        return res

    def hosts_for_role(self, role):
        if role not in self.config:
            raise ValueError("Role %s not found" % role)
        return self.config.get(role)

    def role_for_host(self, hostname):
        return self.host_map().get(hostname, None)


# XXX kludge, the output file needs be writable by 'puppet' user
def update_hiera(pontoon, config_path, hiera_path):
    config_mtime = os.stat(config_path).st_mtime
    hiera_mtime = -1
    if os.path.exists(hiera_path):
        hiera_mtime = os.stat(hiera_path).st_mtime

    if config_mtime > hiera_mtime:
        with open(hiera_path, "w") as f:
            try:
                fcntl.flock(f, fcntl.LOCK_EX)
                yaml.dump(pontoon.role_variables(), f)
                f.flush()
            finally:
                fcntl.flock(f, fcntl.LOCK_UN)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser(description="Pontoon ENC")
    parser.add_argument(
        "hostname",
        type=str,
        default=None,
        nargs="?",
        help="The hostname to return data for",
    )
    parser.add_argument(
        "--stack.path",
        type=str,
        metavar="PATH",
        dest="stack_path",
        default=os.environ.get(
            "PONTOON_STACK_PATH", "/var/lib/git/operations/puppet/modules/pontoon/files"
        ),
        help="The path where all stacks are located",
    )
    parser.add_argument(
        "--stack.file",
        type=str,
        metavar="PATH",
        dest="stack_file",
        default=os.environ.get("PONTOON_STACK_FILE", "/etc/pontoon-stack"),
        help="File with the Pontoon stack, default PONTOON_STACK_FILE / /etc/pontoon-stack",
    )
    parser.add_argument(
        "--hiera.output",
        type=str,
        default=None,
        metavar="PATH",
        dest="hiera_output",
        help="Destination PATH for autogenerated hiera configuration",
    )
    args = parser.parse_args()

    with open(args.stack_file) as f:
        stack = f.readline().strip()

    config = os.path.join(args.stack_path, stack, "rolemap.yaml")

    with open(config, encoding="utf-8") as f:
        p = Pontoon(f)

    if args.hiera_output:
        # Autogenerate hiera variables from Pontoon's map. These variables can be referenced in
        # hiera itself via %{alias('variable')}
        update_hiera(p, config, args.hiera_output)

    role = p.role_for_host(args.hostname)
    if not role:
        log.error("Host %s not found in %s", args.hostname, config)
        sys.exit(-1)

    agent_server = (p.hosts_for_role("puppetmaster::pontoon")[0],)

    variables = {}
    variables.update(
        {
            "puppetmaster": agent_server,
            "labs_puppet_master": agent_server,
            # Set variables for role() emulation
            "_role": role.replace("::", "/"),
            "_roles": {role: "true"},
        }
    )

    yaml.safe_dump(
        {"classes": ["role::%s" % role], "parameters": variables}, sys.stdout
    )
